import{_ as d,o as e,c as o,e as c}from"./app.cc3919a2.js";const a={},r=c('<h1 id="对接其他平台" tabindex="-1"><a class="header-anchor" href="#对接其他平台" aria-hidden="true">#</a> 对接其他平台</h1><p>本章介绍如何在其他平台中对接 <code>SDK</code></p><h2 id="必要步骤" tabindex="-1"><a class="header-anchor" href="#必要步骤" aria-hidden="true">#</a> 必要步骤</h2><p>入口文件引入 <code>xiaozhi.css</code> 和 <code>xiaozhi.umd.cjs</code></p><h2 id="不需要调用业务接口以及自定义展示dom" tabindex="-1"><a class="header-anchor" href="#不需要调用业务接口以及自定义展示dom" aria-hidden="true">#</a> 不需要调用业务接口以及自定义展示dom</h2><p>根目录中放入 <code>gptconfig.json</code></p><p><code>gptconfig.json</code> 中 <code>autoLoad</code> 字段改为 <code>0</code> 自动载入即可</p><h2 id="需要调用业务接口以及展示自定义dom" tabindex="-1"><a class="header-anchor" href="#需要调用业务接口以及展示自定义dom" aria-hidden="true">#</a> 需要调用业务接口以及展示自定义dom</h2><p><code>gptconfig.json</code> 放到任意目录下，将 <code>autoLoad</code> 字段改为 <code>1</code></p><p>调用 <code>SDK</code> 中的 <code>init</code> 方法即可加载</p><p>由于 <code>SDK</code> 中返回的是由 <code>提示词模板</code> 组装的字段，所以这里调用业务接口需要通过 <code>addAnswerFilter</code> 来通过大模型返回的字段来调用某个接口以及替换成想要展示的 <code>dom</code></p><p>通过 <code>addHistoryFilter</code> 将历史会话记录中的数据展示成相对应的 <code>dom</code></p><h3 id="为什么有了-addanswerfilter-还需要-addhistoryfilter" tabindex="-1"><a class="header-anchor" href="#为什么有了-addanswerfilter-还需要-addhistoryfilter" aria-hidden="true">#</a> 为什么有了 <code>addAnswerFilter</code> 还需要 <code>addHistoryFilter</code> ？</h3><p>由于 <code>addAnswerFilter</code> 是针对大模型回答的答案来通过业务接口的访问展示 <code>dom</code> 的，但当我们查看历史会话记录时，不应该再去调用业务接口，否则会造成很多个业务接口请求。</p><h3 id="为什么历史会话记录中不存-dom" tabindex="-1"><a class="header-anchor" href="#为什么历史会话记录中不存-dom" aria-hidden="true">#</a> 为什么历史会话记录中不存 <code>dom</code> ？</h3><p>因为历史会话中存入 <code>dom</code>，并不能将 <code>dom</code> 关联的方法也存入，但是我们又为了避免展开历史会话时发送很多个业务接口请求，在通过 <code>addAnswerFilter</code> 过滤后的结果存入大模型中。</p>',16),i=[r];function t(n,h){return e(),o("div",null,i)}const p=d(a,[["render",t],["__file","index.html.vue"]]);export{p as default};
